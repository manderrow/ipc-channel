const builtin = @import("builtin");
const std = @import("std");

pub const os = switch (builtin.os.tag) {
    .macos => @import("os/macos.zig"),
    else => |os_tag| @compileError("Unsupported OS: " ++ @tagName(os_tag)),
};

pub const channel = os.channel;
pub const Channel = os.OsIpcChannel;
pub const Sender = os.OsIpcSender;
pub const Receiver = os.OsIpcReceiver;
pub const OneShotServer = os.OneShotServer;
pub const OpaqueChannel = os.OsOpaqueIpcChannel;
pub const SharedMemory = os.OsIpcSharedMemory;

pub const IpcMessage = struct {
    data: []u8,
    channels: []OpaqueChannel,
    shared_memory_regions: []SharedMemory,

    pub fn deinit(self: *@This(), alloc: std.mem.Allocator) void {
        alloc.free(self.data);
        for (self.channels) |*chan| {
            chan.deinit();
        }
        alloc.free(self.channels);
        for (self.shared_memory_regions) |*smr| {
            smr.deinit();
        }
        alloc.free(self.shared_memory_regions);
    }
};

fn expectEqualStringMessages(
    expected_data: []const u8,
    expected_channel_count: usize,
    expected_shared_memory_region_count: usize,
    msg: IpcMessage,
) !void {
    try std.testing.expectEqualStrings(expected_data, msg.data);
    try std.testing.expectEqual(expected_channel_count, msg.channels.len);
    try std.testing.expectEqual(expected_shared_memory_region_count, msg.shared_memory_regions.len);
}

test "simple" {
    const alloc = std.testing.allocator;

    var chan = try channel();
    defer chan.rc.deinit();
    defer chan.sd.deinit();

    const data = "1234567";
    try chan.sd.send(alloc, data, &.{}, &.{});
    var ipc_message = try chan.rc.recv(alloc);
    defer ipc_message.deinit(alloc);
    try expectEqualStringMessages(data, 0, 0, ipc_message);
}

test "sender transfer" {
    const alloc = std.testing.allocator;

    var super = try channel();
    defer super.rc.deinit();
    defer super.sd.deinit();

    var sub = try channel();
    defer sub.rc.deinit();
    // sub.sd is immediately handed off to super.sd.send(...), so don't defer dealloc

    const data = "foo";
    var ports: [1]Channel = .{.{ .sender = sub.sd }};
    try super.sd
        .send(alloc, data, &ports, &.{});
    {
        var ipc_message = try super.rc.recv(alloc);
        defer ipc_message.deinit(alloc);

        try std.testing.expectEqual(1, ipc_message.channels.len);
        var sub_tx = try ipc_message.channels[ipc_message.channels.len - 1].asSender();

        try sub_tx.send(alloc, data, &.{}, &.{});
    }

    var ipc_message = try sub.rc.recv(alloc);
    defer ipc_message.deinit(alloc);
    try expectEqualStringMessages(data, 0, 0, ipc_message);
}

test "receiver transfer" {
    return error.ToDo;
}

test "multisender transfer" {
    return error.ToDo;
}

test "medium data" {
    return error.ToDo;
}

test "medium data with sender transfer" {
    return error.ToDo;
}

test "big data" {
    return error.ToDo;
}

test "huge data" {
    return error.ToDo;
}

test "big data with sender transfer" {
    return error.ToDo;
}

// TODO: port fragment_tests

test "empty" {
    return error.ToDo;
}

test "fd only" {
    return error.ToDo;
}

// TODO: port tests generated by create_big_data_with_n_fds

test "concurrent_senders" {
    return error.ToDo;
}

test "receiver_set" {
    return error.ToDo;
}

test "receiver set eintr" {
    return error.ToDo;
}

test "receiver set empty" {
    return error.ToDo;
}

test "receiver set close before adding" {
    return error.ToDo;
}

test "receiver set close after adding" {
    return error.ToDo;
}

test "receiver set medium data" {
    return error.ToDo;
}

test "receiver set big data" {
    return error.ToDo;
}

test "receiver set concurrent" {
    return error.ToDo;
}

test "server accept first" {
    const alloc = std.testing.allocator;

    const data = "1234567";

    var server = try OneShotServer.new();

    var result = blk: {
        // past this block, server is already deinitialized.
        errdefer server.deinit();

        const thread = try std.Thread.spawn(.{}, struct {
            fn f(name: [:0]const u8) void {
                std.time.sleep(30 * std.time.ns_per_ms);
                const tx = Sender.connect(name) catch |e| {
                    std.debug.print("connect: {}", .{e});
                    return;
                };
                tx.send(alloc, data, &.{}, &.{}) catch |e| {
                    std.debug.print("send: {}", .{e});
                    return;
                };
            }
        }.f, .{server.getName()});
        defer thread.join();

        break :blk try server.accept(alloc);
    };
    defer result.msg.deinit(alloc);
    try expectEqualStringMessages(data, 0, 0, result.msg);
}

test "server connect first" {
    return error.ToDo;
}

test "cross process spawn" {
    return error.ToDo;
}

test "cross process fork" {
    return error.ToDo;
}

test "cross process sender transfer spawn" {
    return error.ToDo;
}

test "cross process sender transfer fork" {
    return error.ToDo;
}

test "no senders notification" {
    return error.ToDo;
}

test "no receiver notification" {
    return error.ToDo;
}

test "no receiver notification pending" {
    return error.ToDo;
}

test "no receiver notification delayed" {
    return error.ToDo;
}

test "shared memory" {
    return error.ToDo;
}

test "shared memory clone" {
    return error.ToDo;
}

test "try recv" {
    return error.ToDo;
}

test "no senders notification try recv" {
    return error.ToDo;
}

test "no senders notification try recv delayed" {
    return error.ToDo;
}

test "try recv large" {
    return error.ToDo;
}

test "try recv large delayed" {
    return error.ToDo;
}

test "cross process two step transfer spawn" {
    return error.ToDo;
}
